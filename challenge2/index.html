<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object Avoidance Game</title>
    <script src="./ml5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <script src="./p5.min.js"></script>
    <style>
        body {
            margin: 0;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            transform: scaleX(-1); /* Horizontaal spiegelen van het beeld */
            display: block;
            margin: auto;
        }
        #canvas-container{
          margin-top: -80px;
        }

        .flipped-text {
            transform: scaleX(-1); /* Horizontaal spiegelen van de tekst */
        }

        #header {
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="score">Score: 0</span> | <span id="lives">Lives: 3</span> | <span id="level">Level: 1</span>
    </div>
    <div id="canvas-container">
        <canvas id="defaultCanvas0"></canvas>
    </div>
    <video id="video" style="display:none;"></video>
    <script>
let video;
let poseNet;
let poses = [];
let characterX, characterY;
let obstacles = [];
let bulletPool = [];
let lastBulletTime = 0;
let fireRate = 1000;
let gameWidth = 840;
let gameHeight = 680;
let score = 0;
let level = 1;
let bulletsPerLevel = 1;
let lives = 3;
let obstacleInterval = 2000;
let lastObstacleTime = 0;
const maxBullets = 50; // Maximum aantal kogels in de pool
const bulletSpeed = 5; // Snelheid van de kogels
const obstacleSpeed = 3; // Snelheid van de obstakels

function setup() {
    createCanvas(gameWidth, gameHeight);
    video = createCapture(VIDEO);
    video.size(gameWidth, gameHeight);
    video.hide();

    poseNet = ml5.poseNet(video, modelReady);
    poseNet.on('pose', function(results) {
        poses = results;
    });

    characterX = width / 2;
    characterY = height / 2;

    for (let i = 0; i < maxBullets; i++) {
        bulletPool.push(new Bullet());
    }

    setInterval(addObstacle, obstacleInterval);
    requestAnimationFrame(updateGame);
}

function modelReady() {
    console.log('Model Loaded');
}

function updateGame() {
    background(200);

    if (poses.length > 0) {
        let head = poses[0].pose.keypoints.find(point => point.part === 'nose');

        if (head.score > 0.5) {
            characterX = (head.position.x / video.width) * width;
            characterY = (head.position.y / video.height) * height;

            if (characterY < height / 2 && millis() - lastBulletTime > fireRate) {
                fireBullet();
                lastBulletTime = millis();
            }
        }
    }

    fill(255, 0, 0);
    rect(characterX - 25, characterY - 25, 50, 50);

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let obstacle = obstacles[i];
        obstacle.update();
        obstacle.show();

        for (let j = bulletPool.length - 1; j >= 0; j--) {
            let bullet = bulletPool[j];
            if (bullet.active) {
                bullet.update();
                bullet.show();
                if (bullet.hits(obstacle)) {
                    bullet.deactivate();
                    obstacles.splice(i, 1); // Verwijder het obstakel als het is geraakt door een kogel
                    score++;
                    break;
                }
            }
        }

        if (obstacle.hits(characterX, characterY)) {
            obstacles.splice(i, 1);
            lives--;
            if (lives <= 0) {
                gameOver();
                return;
            }
        }
    }

    document.getElementById('score').innerText = 'Score: ' + score;
    document.getElementById('lives').innerText = 'Lives: ' + lives;
    document.getElementById('level').innerText = 'Level: ' + level;

    requestAnimationFrame(updateGame);
}

function gameOver() {
    fill(0);
    textSize(32);
    textAlign(CENTER);
    text('Game Over', width / 2, height / 2);
    textSize(24);
    text('Score: ' + score, width / 2, height / 2 + 40);
}

function addObstacle() {
    obstacles.push(new Obstacle());
}

function fireBullet() {
    let bullet = bulletPool.find(b => !b.active);
    if (bullet) {
        bullet.activate(characterX, characterY);
    }
}

class Obstacle {
    constructor
    () {
        this.x = random(width);
        this.y = random(-height, 0);
        this.size = random(50, 70);
        this.speed = obstacleSpeed; // Pas de snelheid van het obstakel aan
    }

    update() {
        this.y += this.speed;

        if (this.y > height) {
            this.y = random(-height, 0);
            this.x = random(width);
            score++;

            if (score % 10 === 0) {
                level++;
                bulletsPerLevel += level;
                let additionalObstacles = level * 0.05;

                if (additionalObstacles >= 1) {
                    for (let i = 0; i < Math.floor(additionalObstacles); i++) {
                        obstacles.push(new Obstacle());
                    }
                }

                if (random(1) < additionalObstacles % 1) {
                    obstacles.push(new Obstacle());
                }

                for (let obstacle of obstacles) {
                    obstacle.speed += 0.05; // Verhoog de snelheid van de obstakels
                }
            }
        }
    }

    show() {
        fill(0);
        ellipse(this.x, this.y, this.size);
    }

    hits(px, py) {
        let d = dist(this.x, this.y, px, py);
        return (d < this.size / 2 + 25);
    }
}

class Bullet {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.size = 5;
        this.speed = bulletSpeed; // Pas de snelheid van de kogel aan
        this.active = false;
    }

    activate(x, y) {
        this.x = x;
        this.y = y;
        this.active = true;
    }

    deactivate() {
        this.active = false;
    }

    update() {
        this.y -= this.speed;
        if (this.y < 0) {
            this.deactivate();
        }
    }

    show() {
        fill(0, 255, 0);
        ellipse(this.x, this.y, this.size);
    }

    hits(obstacle) {
        let d = dist(this.x, this.y, obstacle.x, obstacle.y);
        return (d < this.size / 2 + obstacle.size / 2);
    }
}
</script>
</body>

</html>
